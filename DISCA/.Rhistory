# Date: Apr 17, 2018
# The following functions in other packages are going to be used.
# energy::dcov()
# MASS:Null()
p <- ncol(X)
q <- ncol(Y)
Num <- nrow(X)
X_0 <- X
Y_0 <- Y
# ninv = qnorm(1-alpha/2)^2
# Normalize X and Y matrix:
X_0 <- sweep(X_0, 2, colMeans(X_0))
Y_0 <- sweep(Y_0, 2, colMeans(Y_0))
X_0 <- sweep(X_0, 2, sqrt(colSums(X_0^2))/sqrt(Num), FUN = "/")
Y_0 <- sweep(Y_0, 2, sqrt(colSums(Y_0^2))/sqrt(Num), FUN = "/")
X_diff <- Xdiff(X_0)  # The matrix of the pairwise difference of X.
Y_diff <- Xdiff(Y_0)  # The matrix of the pairwise difference of Y.
gM_Y <- gMatrix(Y_0)
g_Y <- gM_Y$gM  # g-Matrix of Y.
# sum4_Y <- gM_Y$sum4  # sum4 of Y.
U_n = matrix(0,0,p)  # each row represents a direction.
U = diag(p)  # Null space of U_n.
DC_X = 0
THRES_X = numeric(0)
X_diff_proj = X_diff
p_1 = p
for (DIM in 1:(p-1)){  # Check if the reduced dimension can reach DIM.
X_diff_proj = X_diff%*%U
u <- maxDCOV(X_diff_proj,g_Y)
u_ult = (1/sqrt(sum((U_n%*%u)^2)))*U_n%*%u    # New direction in U_n.
test_sum <- dcovU.test(X_0%*%u_ult, Y, R = R, alpha = alpha)
dc_0 = test_sum$estimate
DC_X = c(DC_X,dc_0)
p_1 = p_1-1;
threshold = test_sum$threshold
THRES_X = c(THRES_X,threshold)
if (dc_0<threshold){
DIM <- DIM-1  # Failure in this attempt.
break
}
U_n <- rbind(U,t(u_ult))
U <- Null(t(U))
sprintf('Finished dimension %d of W_1\n',DIM)
}
if (DIM==p-1){
test_sum <- dcovU.test(X_0%*%U_n,Y_0)
dc_0 = test_sum$estimate
threshold = test_sum$threshold
DC_X = c(DC_X,dc_0)
THRES_X = c(THRES_X,threshold)
if (dc_0>threshold){
DIM = p
U = matrix(0,0,0)
}
}
dim1 <- DIM
############################################################
V_n = matrix(0,0,q)  # each row represents a direction.
V = diag(q)  # Null space of V.
DC_Y = 0
THRES_Y = numeric(0)
Y_diff_proj = Y_diff
q_1 = q
if (p-DIM==0){
X_p = X_0
}else{
X_p = X_0%*%U_n
}
gM_Xp <- gMatrix(X_p)
g_X <- gM_Xp$gM  # g-Matrix of Xp.
# sum4_X <- gM_Xp$sum4  # sum4 of Xp.
for (DIM in 1:(q-1)){
Y_diff_proj = Y_diff%*%V
v = maxDCOV(Y_diff_proj,g_X)
v_ult = (1/sqrt(sum((V_n%*%v)^2)))*V_n%*%v
test_sum <- dcovU.test(Y_0%*%v_ult, X_0, R = R, alpha = alpha)
dc_0 = test_sum$estimate
DC_Y = c(DC_Y,dc_0)
q_1 = q_1-1
threshold = test_sum$threshold
THRES_Y = c(THRES_Y,threshold)
if (dc_0<threshold){
DIM <- DIM-1
break
}
V_n <- rbind(V,t(v_ult))f
V <- Null(t(V))
sprintf('Finished dimension %d of W_2\n',DIM)
}
if (DIM==q-1){
test_sum <- dcovU.test(Y_0%*%v_ult, X_0, R = R, alpha = alpha)
dc_0 = test_sum$estimate
threshold = test_sum$threshold
DC_Y = c(DC_Y,dc_0)
THRES_Y = c(THRES_Y,threshold)
if (dc_0>threshold){
DIM = q
V = matrix(0,0,0)
}
}
dim2 <- DIM
return(list(dW1=dim1,basis.W1=U_n,dW2=dim2,basis.W2=V_n))
}
DISCA_fwd <- function(X,Y,e=10^-3,
xi=200,psi=10,rho=1000,omega=10,abs.epsilon=10^-3,rel.epsilon=10^-3,alpha=0.05,R=1000) {
# Author: Chuanping Yu
# Date: Apr 17, 2018
# The following functions in other packages are going to be used.
# energy::dcov()
# MASS:Null()
p <- ncol(X)
q <- ncol(Y)
Num <- nrow(X)
X_0 <- X
Y_0 <- Y
# ninv = qnorm(1-alpha/2)^2
# Normalize X and Y matrix:
X_0 <- sweep(X_0, 2, colMeans(X_0))
Y_0 <- sweep(Y_0, 2, colMeans(Y_0))
X_0 <- sweep(X_0, 2, sqrt(colSums(X_0^2))/sqrt(Num), FUN = "/")
Y_0 <- sweep(Y_0, 2, sqrt(colSums(Y_0^2))/sqrt(Num), FUN = "/")
X_diff <- Xdiff(X_0)  # The matrix of the pairwise difference of X.
Y_diff <- Xdiff(Y_0)  # The matrix of the pairwise difference of Y.
gM_Y <- gMatrix(Y_0)
g_Y <- gM_Y$gM  # g-Matrix of Y.
# sum4_Y <- gM_Y$sum4  # sum4 of Y.
U_n = matrix(0,0,p)  # each row represents a direction.
U = diag(p)  # Null space of U_n.
DC_X = 0
THRES_X = numeric(0)
X_diff_proj = X_diff
p_1 = p
for (DIM in 1:(p-1)){  # Check if the reduced dimension can reach DIM.
X_diff_proj = X_diff%*%U
u <- maxDCOV(X_diff_proj,g_Y)
u_ult = (1/sqrt(sum((U_n%*%u)^2)))*U_n%*%u    # New direction in U_n.
test_sum <- dcovU.test(X_0%*%u_ult, Y, R = R, alpha = alpha)
dc_0 = test_sum$estimate
DC_X = c(DC_X,dc_0)
p_1 = p_1-1;
threshold = test_sum$threshold
THRES_X = c(THRES_X,threshold)
if (dc_0<threshold){
DIM <- DIM-1  # Failure in this attempt.
break
}
U_n <- rbind(U,t(u_ult))
U <- Null(t(U))
sprintf('Finished dimension %d of W_1\n',DIM)
}
if (DIM==p-1){
test_sum <- dcovU.test(X_0%*%U_n,Y_0)
dc_0 = test_sum$estimate
threshold = test_sum$threshold
DC_X = c(DC_X,dc_0)
THRES_X = c(THRES_X,threshold)
if (dc_0>threshold){
DIM = p
U = matrix(0,0,0)
}
}
dim1 <- DIM
############################################################
V_n = matrix(0,0,q)  # each row represents a direction.
V = diag(q)  # Null space of V.
DC_Y = 0
THRES_Y = numeric(0)
Y_diff_proj = Y_diff
q_1 = q
if (p-DIM==0){
X_p = X_0
}else{
X_p = X_0%*%U_n
}
gM_Xp <- gMatrix(X_p)
g_X <- gM_Xp$gM  # g-Matrix of Xp.
# sum4_X <- gM_Xp$sum4  # sum4 of Xp.
for (DIM in 1:(q-1)){
Y_diff_proj = Y_diff%*%V
v = maxDCOV(Y_diff_proj,g_X)
v_ult = (1/sqrt(sum((V_n%*%v)^2)))*V_n%*%v
test_sum <- dcovU.test(Y_0%*%v_ult, X_0, R = R, alpha = alpha)
dc_0 = test_sum$estimate
DC_Y = c(DC_Y,dc_0)
q_1 = q_1-1
threshold = test_sum$threshold
THRES_Y = c(THRES_Y,threshold)
if (dc_0<threshold){
DIM <- DIM-1
break
}
V_n <- rbind(V,t(v_ult))f
V <- Null(t(V))
sprintf('Finished dimension %d of W_2\n',DIM)
}
if (DIM==q-1){
test_sum <- dcovU.test(Y_0%*%v_ult, X_0, R = R, alpha = alpha)
dc_0 = test_sum$estimate
threshold = test_sum$threshold
DC_Y = c(DC_Y,dc_0)
THRES_Y = c(THRES_Y,threshold)
if (dc_0>threshold){
DIM = q
V = matrix(0,0,0)
}
}
dim2 <- DIM
return(list(dW1=dim1,basis.W1=U_n,dW2=dim2,basis.W2=V_n))
}
DISCA_fwd <- function(X,Y,e=10^-3,
xi=200,psi=10,rho=1000,omega=10,abs.epsilon=10^-3,rel.epsilon=10^-3,alpha=0.05,R=1000) {
# Author: Chuanping Yu
# Date: Apr 17, 2018
# The following functions in other packages are going to be used.
# energy::dcov()
# MASS:Null()
p <- ncol(X)
q <- ncol(Y)
Num <- nrow(X)
X_0 <- X
Y_0 <- Y
# ninv = qnorm(1-alpha/2)^2
# Normalize X and Y matrix:
X_0 <- sweep(X_0, 2, colMeans(X_0))
Y_0 <- sweep(Y_0, 2, colMeans(Y_0))
X_0 <- sweep(X_0, 2, sqrt(colSums(X_0^2))/sqrt(Num), FUN = "/")
Y_0 <- sweep(Y_0, 2, sqrt(colSums(Y_0^2))/sqrt(Num), FUN = "/")
X_diff <- Xdiff(X_0)  # The matrix of the pairwise difference of X.
Y_diff <- Xdiff(Y_0)  # The matrix of the pairwise difference of Y.
gM_Y <- gMatrix(Y_0)
g_Y <- gM_Y$gM  # g-Matrix of Y.
# sum4_Y <- gM_Y$sum4  # sum4 of Y.
U_n = matrix(0,0,p)  # each row represents a direction.
U = diag(p)  # Null space of U_n.
DC_X = 0
THRES_X = numeric(0)
X_diff_proj = X_diff
p_1 = p
for (DIM in 1:(p-1)){  # Check if the reduced dimension can reach DIM.
X_diff_proj = X_diff%*%U
u <- maxDCOV(X_diff_proj,g_Y)
u_ult = (1/sqrt(sum((U_n%*%u)^2)))*U_n%*%u    # New direction in U_n.
test_sum <- dcovU.test(X_0%*%u_ult, Y, R = R, alpha = alpha)
dc_0 = test_sum$estimate
DC_X = c(DC_X,dc_0)
p_1 = p_1-1;
threshold = test_sum$threshold
THRES_X = c(THRES_X,threshold)
if (dc_0<threshold){
DIM <- DIM-1  # Failure in this attempt.
break
}
U_n <- rbind(U,t(u_ult))
U <- Null(t(U))
sprintf('Finished dimension %d of W_1\n',DIM)
}
if (DIM==p-1){
test_sum <- dcovU.test(X_0%*%U_n,Y_0)
dc_0 = test_sum$estimate
threshold = test_sum$threshold
DC_X = c(DC_X,dc_0)
THRES_X = c(THRES_X,threshold)
if (dc_0>threshold){
DIM = p
U = matrix(0,0,0)
}
}
dim1 <- DIM
############################################################
V_n = matrix(0,0,q)  # each row represents a direction.
V = diag(q)  # Null space of V.
DC_Y = 0
THRES_Y = numeric(0)
Y_diff_proj = Y_diff
q_1 = q
if (p-DIM==0){
X_p = X_0
}else{
X_p = X_0%*%U_n
}
gM_Xp <- gMatrix(X_p)
g_X <- gM_Xp$gM  # g-Matrix of Xp.
# sum4_X <- gM_Xp$sum4  # sum4 of Xp.
for (DIM in 1:(q-1)){
Y_diff_proj = Y_diff%*%V
v = maxDCOV(Y_diff_proj,g_X)
v_ult = (1/sqrt(sum((V_n%*%v)^2)))*V_n%*%v
test_sum <- dcovU.test(Y_0%*%v_ult, X_0, R = R, alpha = alpha)
dc_0 = test_sum$estimate
DC_Y = c(DC_Y,dc_0)
q_1 = q_1-1
threshold = test_sum$threshold
THRES_Y = c(THRES_Y,threshold)
if (dc_0<threshold){
DIM <- DIM-1
break
}
V_n <- rbind(V,t(v_ult))
V <- Null(t(V))
sprintf('Finished dimension %d of W_2\n',DIM)
}
if (DIM==q-1){
test_sum <- dcovU.test(Y_0%*%v_ult, X_0, R = R, alpha = alpha)
dc_0 = test_sum$estimate
threshold = test_sum$threshold
DC_Y = c(DC_Y,dc_0)
THRES_Y = c(THRES_Y,threshold)
if (dc_0>threshold){
DIM = q
V = matrix(0,0,0)
}
}
dim2 <- DIM
return(list(dW1=dim1,basis.W1=U_n,dW2=dim2,basis.W2=V_n))
}
maxDCOV(X_diff,g_Y)
X_diff
maxCOV <- function(Xd,gM,u0=c(1,rep(0,ncol(Xd)-1)),e=10^-3,
xi=200,psi=10,rho=1000,omega=10,abs.epsilon=10^-3,rel.epsilon=10^-3) {
# Author: Chuanping Yu
# Date: Apr 17, 2018
p <- ncol(Xd)
M_plus <- Mminus(gM,Xd)  # The M plus matrix.
M_minus <- Mplus(gM,Xd)  # The M minus matrix.
# Normalize u0 if the l2 norm of u0 is not equal to 1.
if (sum(u0^2)==0){
u0 = c(1,rep(0,p-1))
}
if (sqrt(sum(u0^2))!=1){
u0 <- (1/sqrt(sum(u0^2)))*u0
}
index <- 0
u_pre <- u0
u <- rep(0,p)
while (min(sqrt(sum((u-u_pre)^2)),sqrt(sum((u+u_pre)^2)))/max(sqrt(sum(u^2)),1)>e){
index <- index+1
u <- u_pre
sig <- sign(M_minus%*%u)
partial <- sig
sig_zero <- sig[sig==0]
if (sum(sig==0)>0){
sig_zero <- runif(length(sig_zero),min=-1,max=1)
partial[sig==0] = sig_zero
}
if (sum(abs(u-rep(0,p)))==0){
y = t(M_minus)%*%partial
}else{
y = ((xi-psi)/sqrt(sum(u^2)))*u+t(M_minus)%*%partial
}
z = M_plus%*%u;
v = 10*rep(1,nrow(M_plus))
for (l in 1:10^5){
u_l = solve(xi*diag(p)+rho*(t(M_plus)%*%M_plus))%*%(y+t(M_plus)%*%(rho*z-v))
x = (1/rho)*v+M_plus%*%u_l
z_l = sign(x)*apply(cbind(abs(x)-1/rho,rep(0,length(x))),1,max)
v = v+rho*(M_plus%*%u_l-z_l)
r = M_plus%*%u_l-z_l
s = rho*t(M_plus)%*%(z_l-z)
if (sqrt(sum(r^2))<=sqrt(nrow(M_plus))*abs.epsilon+rel.epsilon*max(sqrt(sum((M_plus%*%u_l)^2)),sqrt(sum(z_l^2))) &&
sqrt(sum(s^2))<=sqrt(p)*abs.epsilon+rel.epsilon*sqrt(sum(t(M_plus)%*%v)^2)){
break
}
z <- z_l
}
u_pre <- u_l
psi <- psi + xi*(sqrt(sum(u_pre^2))-1);
xi <- omega*xi
}
return(u_pre)
}
maxDCOV(X_diff,g_Y)
maxDCOV <- function(Xd,gM,u0=c(1,rep(0,ncol(Xd)-1)),e=10^-3,
xi=200,psi=10,rho=1000,omega=10,abs.epsilon=10^-3,rel.epsilon=10^-3) {
# Author: Chuanping Yu
# Date: Apr 17, 2018
p <- ncol(Xd)
M_plus <- Mminus(gM,Xd)  # The M plus matrix.
M_minus <- Mplus(gM,Xd)  # The M minus matrix.
# Normalize u0 if the l2 norm of u0 is not equal to 1.
if (sum(u0^2)==0){
u0 = c(1,rep(0,p-1))
}
if (sqrt(sum(u0^2))!=1){
u0 <- (1/sqrt(sum(u0^2)))*u0
}
index <- 0
u_pre <- u0
u <- rep(0,p)
while (min(sqrt(sum((u-u_pre)^2)),sqrt(sum((u+u_pre)^2)))/max(sqrt(sum(u^2)),1)>e){
index <- index+1
u <- u_pre
sig <- sign(M_minus%*%u)
partial <- sig
sig_zero <- sig[sig==0]
if (sum(sig==0)>0){
sig_zero <- runif(length(sig_zero),min=-1,max=1)
partial[sig==0] = sig_zero
}
if (sum(abs(u-rep(0,p)))==0){
y = t(M_minus)%*%partial
}else{
y = ((xi-psi)/sqrt(sum(u^2)))*u+t(M_minus)%*%partial
}
z = M_plus%*%u;
v = 10*rep(1,nrow(M_plus))
for (l in 1:10^5){
u_l = solve(xi*diag(p)+rho*(t(M_plus)%*%M_plus))%*%(y+t(M_plus)%*%(rho*z-v))
x = (1/rho)*v+M_plus%*%u_l
z_l = sign(x)*apply(cbind(abs(x)-1/rho,rep(0,length(x))),1,max)
v = v+rho*(M_plus%*%u_l-z_l)
r = M_plus%*%u_l-z_l
s = rho*t(M_plus)%*%(z_l-z)
if (sqrt(sum(r^2))<=sqrt(nrow(M_plus))*abs.epsilon+rel.epsilon*max(sqrt(sum((M_plus%*%u_l)^2)),sqrt(sum(z_l^2))) &&
sqrt(sum(s^2))<=sqrt(p)*abs.epsilon+rel.epsilon*sqrt(sum(t(M_plus)%*%v)^2)){
break
}
z <- z_l
}
u_pre <- u_l
psi <- psi + xi*(sqrt(sum(u_pre^2))-1);
xi <- omega*xi
}
return(u_pre)
}
View(maxCOV)
View(maxCOV)
maxDCOV(X_diff,g_Y)
X = X[1:200,]
Y = Y[1:200,]
Num <- nrow(X)
X_0 <- X
Y_0 <- Y
# ninv = qnorm(1-alpha/2)^2
# Normalize X and Y matrix:
X_0 <- sweep(X_0, 2, colMeans(X_0))
Y_0 <- sweep(Y_0, 2, colMeans(Y_0))
X_0 <- sweep(X_0, 2, sqrt(colSums(X_0^2))/sqrt(Num), FUN = "/")
Y_0 <- sweep(Y_0, 2, sqrt(colSums(Y_0^2))/sqrt(Num), FUN = "/")
X_0
dim(X_0)
X <- X[,1:200]
Y <- I(X%*%beta_1 + 0.2*epsilon > 1) + 2*I(X%*%beta_2 + 0.2*epsilon>0)
beta_1 <- beta_1[1:200]
beta_2 <- beta_2[1:200]
Y <- I(X%*%beta_1 + 0.2*epsilon > 1) + 2*I(X%*%beta_2 + 0.2*epsilon>0)
p <- ncol(X)
q <- ncol(Y)
Num <- nrow(X)
X_0 <- X
Y_0 <- Y
# ninv = qnorm(1-alpha/2)^2
# Normalize X and Y matrix:
X_0 <- sweep(X_0, 2, colMeans(X_0))
Y_0 <- sweep(Y_0, 2, colMeans(Y_0))
X_0 <- sweep(X_0, 2, sqrt(colSums(X_0^2))/sqrt(Num), FUN = "/")
Y_0 <- sweep(Y_0, 2, sqrt(colSums(Y_0^2))/sqrt(Num), FUN = "/")
X_diff <- Xdiff(X_0)  # The matrix of the pairwise difference of X.
Y_diff <- Xdiff(Y_0)  # The matrix of the pairwise difference of Y.
gM_Y <- gMatrix(Y_0)
g_Y <- gM_Y$gM  # g-Matrix of Y.
maxDCOV(X_diff,g_Y)
X <- X[,1:5]
beta_1 <- beta_1[1:5]
beta_1 <- c(beta_1, rep(0,5))
X <- mvrnorm(200, rep(0,10), diag(10))
dim(X)
beta_2 <- beta_2[1:10]
Y <- I(X%*%beta_1 + 0.2*epsilon > 1) + 2*I(X%*%beta_2 + 0.2*epsilon>0)
p <- ncol(X)
q <- ncol(Y)
Num <- nrow(X)
X_0 <- X
Y_0 <- Y
# ninv = qnorm(1-alpha/2)^2
# Normalize X and Y matrix:
X_0 <- sweep(X_0, 2, colMeans(X_0))
Y_0 <- sweep(Y_0, 2, colMeans(Y_0))
X_0 <- sweep(X_0, 2, sqrt(colSums(X_0^2))/sqrt(Num), FUN = "/")
Y_0 <- sweep(Y_0, 2, sqrt(colSums(Y_0^2))/sqrt(Num), FUN = "/")
X_diff <- Xdiff(X_0)  # The matrix of the pairwise difference of X.
Y_diff <- Xdiff(Y_0)  # The matrix of the pairwise difference of Y.
gM_Y <- gMatrix(Y_0)
g_Y <- gM_Y$gM  # g-Matrix of Y.
# sum4_Y <- gM_Y$sum4  # sum4 of Y.
maxDCOV(X_diff, g_Y)
X <- X[,1:5]
beta_1 <- beta_1[1:5]
beta_2 <- beta_2[1:5]
X <- mvrnorm(200, rep(0,5), diag(5))
Y <- I(X%*%beta_1 + 0.2*epsilon > 1) + 2*I(X%*%beta_2 + 0.2*epsilon>0)
p <- ncol(X)
q <- ncol(Y)
Num <- nrow(X)
X_0 <- X
Y_0 <- Y
# ninv = qnorm(1-alpha/2)^2
# Normalize X and Y matrix:
X_0 <- sweep(X_0, 2, colMeans(X_0))
Y_0 <- sweep(Y_0, 2, colMeans(Y_0))
X_0 <- sweep(X_0, 2, sqrt(colSums(X_0^2))/sqrt(Num), FUN = "/")
Y_0 <- sweep(Y_0, 2, sqrt(colSums(Y_0^2))/sqrt(Num), FUN = "/")
X_diff <- Xdiff(X_0)  # The matrix of the pairwise difference of X.
Y_diff <- Xdiff(Y_0)  # The matrix of the pairwise difference of Y.
gM_Y <- gMatrix(Y_0)
g_Y <- gM_Y$gM  # g-Matrix of Y.
# sum4_Y <- gM_Y$sum4  # sum4 of Y.
X_diff_proj = X_diff
maxDCOV(X_diff_proj,g_Y)
install.packages('devtools')
install.packages('roxygen2')
roxygen2::roxygenize(package.dir = ".")
devtools::check()
